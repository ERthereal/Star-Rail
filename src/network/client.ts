import { MessageType, PartialMessage } from "@protobuf-ts/runtime";
import { Kcp } from "kcp-ts";
import { PacketHead } from "../../resources/autogenerated/head";
import { PacketIds } from "../../resources/ids";
import { cloneBuffer, Crypto } from "../utils/crypto";
import { Logger } from "../utils/log";
import { AddressInfo, NetworkManager } from "./network";
import { DataPacket } from "./packet";

export class Client {

    readonly kcp: Kcp;

    public key: Buffer | undefined;

    constructor(readonly clientManager: ClientManager, readonly address: AddressInfo, readonly conv: number, readonly token: number) {
        this.kcp = new Kcp(conv, token, (buffer) => {
            buffer = cloneBuffer(buffer);
            clientManager.networkManager.send(buffer, address);
        });
        this.kcp.setNodelay(true, 2, true);
        this.kcp.setInterval(10);
        this.kcp.setWndSize(1024, 1024);
    }

    public recv(): DataPacket[] {
        const packets = [];
        for (; ;) {
            const buffer = this.clientManager.networkManager.sharedBuffer;
            const read = this.kcp.recv(buffer);
            if (read === -1 || read === -2) {
                break;
            }

            if (read === -3) {
                Logger.error("Buffer is too small");
                break;
            }
            const decrypted = cloneBuffer(buffer.slice(0, read));
            const packet = DataPacket.decode(decrypted);
            if (packet) {
                packets.push(packet);
            } else {
                continue;
            }
        }
        return packets;
    }

    public generateKey(secretKey: bigint) {
        const mt = this.clientManager.networkManager.random;
        mt.seed(secretKey);
        mt.seed(mt.next());
        mt.next();

        this.key = Buffer.alloc(4096);
        for (let i = 0; i < 4096; i += 8) {
            this.key.writeBigUint64BE(mt.next(), i);
        }
    }

    public getKey(): Buffer {
        return this.key === undefined ? Crypto.ec2b.key : this.key;
    }

    public sendPacket<T extends object>(type: MessageType<T>, message: PartialMessage<T>) {
        const name = type.typeName.split("proto.")[1] as keyof typeof PacketIds; //workaround cause im a lazy fuck ðŸ¥º
        const buffer = type.toBinary(message as T);
        const id = PacketIds[name];
        const metadata = PacketHead.create({
            packetId: id,
            userId: 1,
        });
        Logger.log(JSON.stringify(type.toJson(message as T), null , 2));
        this.sendRaw(new DataPacket(id, Buffer.from(buffer), Buffer.from(PacketHead.toBinary(metadata))));
    }

    public sendRaw(packet: DataPacket) {
        Logger.log("Sending packet with ID: " + PacketIds[packet.id]);
        const buffer = packet.encode();
        this.kcp.send(buffer);
    }
}

export class ClientManager {
    public readonly clients = new Map<string, Client>();

    constructor(readonly networkManager: NetworkManager) { }

    public get(address: AddressInfo): Client | undefined {
        return this.clients.get(address.address + ":" + address.port);
    }

    public add(address: AddressInfo, conv: number, token: number) {
        this.clients.set(address.address + ":" + address.port, new Client(this, address, conv, token));
    }

    public remove(address: AddressInfo) {
        this.clients.delete(address.address + ":" + address.port);
    }
}
